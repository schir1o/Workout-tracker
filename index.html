<!DOCTYPE html>

<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Schwarzes Loch</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

```
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
    }
    
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
    
    .controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0.8), transparent);
        padding: 20px 16px 30px;
        padding-bottom: max(30px, env(safe-area-inset-bottom));
    }
    
    .control-row {
        margin-bottom: 16px;
    }
    
    .control-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        color: #aaa;
        font-size: 13px;
    }
    
    .control-value {
        color: #ff6b35;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
    }
    
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 36px;
        background: transparent;
        cursor: pointer;
    }
    
    input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        background: rgba(255,255,255,0.15);
        border-radius: 3px;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 28px;
        height: 28px;
        background: #ff6b35;
        border-radius: 50%;
        margin-top: -11px;
        box-shadow: 0 2px 10px rgba(255,107,53,0.5);
    }
    
    input[type="range"]::-moz-range-track {
        height: 6px;
        background: rgba(255,255,255,0.15);
        border-radius: 3px;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 28px;
        height: 28px;
        background: #ff6b35;
        border-radius: 50%;
        border: none;
    }
    
    .toggle-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
    }
    
    .toggle-label {
        color: #aaa;
        font-size: 13px;
    }
    
    .toggle {
        position: relative;
        width: 50px;
        height: 30px;
    }
    
    .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .toggle-slider {
        position: absolute;
        inset: 0;
        background: rgba(255,255,255,0.15);
        border-radius: 15px;
        transition: 0.3s;
    }
    
    .toggle-slider:before {
        content: '';
        position: absolute;
        width: 24px;
        height: 24px;
        left: 3px;
        top: 3px;
        background: #666;
        border-radius: 50%;
        transition: 0.3s;
    }
    
    .toggle input:checked + .toggle-slider {
        background: #ff6b35;
    }
    
    .toggle input:checked + .toggle-slider:before {
        transform: translateX(20px);
        background: #fff;
    }
    
    .info {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 16px;
        padding-top: max(16px, env(safe-area-inset-top));
        background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        display: flex;
        justify-content: space-around;
        text-align: center;
    }
    
    .info-item {
        flex: 1;
    }
    
    .info-label {
        font-size: 10px;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
    }
    
    .info-value {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        font-variant-numeric: tabular-nums;
    }
    
    .info-value.accent {
        color: #ff6b35;
    }
    
    .hint {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: rgba(255,255,255,0.3);
        font-size: 14px;
        text-align: center;
        pointer-events: none;
        transition: opacity 0.5s;
    }
    
    .hint.hidden {
        opacity: 0;
    }
</style>
```

</head>
<body>
    <canvas id="canvas"></canvas>

```
<div class="info">
    <div class="info-item">
        <div class="info-label">Masse</div>
        <div class="info-value" id="infoMass">10 M☉</div>
    </div>
    <div class="info-item">
        <div class="info-label">Radius</div>
        <div class="info-value accent" id="infoRs">29.5 km</div>
    </div>
    <div class="info-item">
        <div class="info-label">Photonenring</div>
        <div class="info-value" id="infoPhoton">44.3 km</div>
    </div>
</div>

<div class="hint" id="hint">Pinch zum Zoomen<br>Wischen zum Drehen</div>

<div class="controls">
    <div class="control-row">
        <div class="control-label">
            <span>Masse des Schwarzen Lochs</span>
            <span class="control-value" id="massVal">10 M☉</span>
        </div>
        <input type="range" id="mass" min="1" max="100" value="10">
    </div>
    
    <div class="control-row">
        <div class="control-label">
            <span>Scheibentemperatur</span>
            <span class="control-value" id="tempVal">6000 K</span>
        </div>
        <input type="range" id="temp" min="2000" max="15000" step="100" value="6000">
    </div>
    
    <div class="toggle-row">
        <span class="toggle-label">Akkretionsscheibe</span>
        <label class="toggle">
            <input type="checkbox" id="showDisk" checked>
            <span class="toggle-slider"></span>
        </label>
    </div>
    
    <div class="toggle-row">
        <span class="toggle-label">Sterne</span>
        <label class="toggle">
            <input type="checkbox" id="showStars" checked>
            <span class="toggle-slider"></span>
        </label>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // State
    const state = {
        mass: 10,
        temp: 6000,
        showDisk: true,
        showStars: true,
        rotation: 0,
        zoom: 1,
        time: 0
    };
    
    let stars = [];
    let width, height, centerX, centerY;
    
    // Touch handling
    let lastTouches = [];
    let lastDistance = 0;
    let hintTimeout;
    
    // Physics
    function getRS(mass) { return 2.95 * mass; }
    
    // Blackbody color
    function blackbodyColor(temp) {
        const t = temp / 100;
        let r, g, b;
        
        if (t <= 66) {
            r = 255;
            g = Math.max(0, Math.min(255, 99.47 * Math.log(t) - 161.12));
            b = t <= 19 ? 0 : Math.max(0, Math.min(255, 138.52 * Math.log(t - 10) - 305.04));
        } else {
            r = Math.max(0, Math.min(255, 329.7 * Math.pow(t - 60, -0.133)));
            g = Math.max(0, Math.min(255, 288.12 * Math.pow(t - 60, -0.0755)));
            b = 255;
        }
        
        return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
    }
    
    // Generate stars
    function generateStars() {
        stars = [];
        const count = Math.min(300, Math.floor(width * height / 3000));
        
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 0.3 + Math.random() * 0.7;
            
            stars.push({
                angle,
                dist,
                size: Math.random() * 1.5 + 0.5,
                brightness: Math.random() * 0.6 + 0.4,
                twinkleSpeed: Math.random() * 2 + 1
            });
        }
    }
    
    // Resize
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        
        ctx.scale(dpr, dpr);
        
        centerX = width / 2;
        centerY = height / 2;
        
        generateStars();
    }
    
    // Draw
    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        const rs = getRS(state.mass);
        const baseScale = Math.min(width, height) / 400;
        const scale = baseScale * state.zoom;
        
        // Stars with lensing effect
        if (state.showStars) {
            stars.forEach(star => {
                const angle = star.angle + state.rotation;
                const maxR = Math.min(width, height) * 0.5 * star.dist;
                
                // Simple gravitational lensing approximation
                const lensedDist = maxR + rs * scale * 2 / (maxR / (rs * scale) + 1);
                
                const x = centerX + Math.cos(angle) * lensedDist;
                const y = centerY + Math.sin(angle) * lensedDist;
                
                const twinkle = 0.7 + 0.3 * Math.sin(state.time * star.twinkleSpeed);
                
                ctx.beginPath();
                ctx.arc(x, y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${star.brightness * twinkle})`;
                ctx.fill();
            });
        }
        
        // Accretion disk (back part)
        if (state.showDisk) {
            drawDisk(scale, rs, true);
        }
        
        // Black hole glow
        const glowGrad = ctx.createRadialGradient(
            centerX, centerY, rs * scale * 0.8,
            centerX, centerY, rs * scale * 4
        );
        glowGrad.addColorStop(0, 'rgba(0,0,0,0)');
        glowGrad.addColorStop(0.3, 'rgba(255,100,30,0.1)');
        glowGrad.addColorStop(0.6, 'rgba(255,50,10,0.05)');
        glowGrad.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, rs * scale * 4, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        // Photon sphere
        ctx.beginPath();
        ctx.arc(centerX, centerY, rs * 1.5 * scale, 0, Math.PI * 2);
        const photonGrad = ctx.createRadialGradient(
            centerX, centerY, rs * 1.5 * scale - 3,
            centerX, centerY, rs * 1.5 * scale + 3
        );
        photonGrad.addColorStop(0, 'transparent');
        photonGrad.addColorStop(0.5, 'rgba(255,200,100,0.4)');
        photonGrad.addColorStop(1, 'transparent');
        ctx.strokeStyle = photonGrad;
        ctx.lineWidth = 6;
        ctx.stroke();
        
        // Event horizon
        const bhGrad = ctx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, rs * scale * 1.2
        );
        bhGrad.addColorStop(0, '#000');
        bhGrad.addColorStop(0.85, '#000');
        bhGrad.addColorStop(0.95, 'rgba(40,15,0,0.9)');
        bhGrad.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, rs * scale * 1.2, 0, Math.PI * 2);
        ctx.fillStyle = bhGrad;
        ctx.fill();
        
        // Accretion disk (front part)
        if (state.showDisk) {
            drawDisk(scale, rs, false);
        }
    }
    
    function drawDisk(scale, rs, isBack) {
        const innerR = rs * 3 * scale;
        const outerR = rs * 12 * scale;
        const color = blackbodyColor(state.temp);
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(state.rotation * 0.1);
        ctx.scale(1, 0.25);
        
        // Draw arc (back or front half)
        const startAngle = isBack ? Math.PI : 0;
        const endAngle = isBack ? Math.PI * 2 : Math.PI;
        
        for (let r = innerR; r < outerR; r += 2) {
            const t = (r - innerR) / (outerR - innerR);
            const alpha = (1 - t) * (isBack ? 0.3 : 0.7);
            const tempFactor = Math.pow(1 - t, 0.75);
            const localColor = blackbodyColor(state.temp * tempFactor + 2000);
            
            ctx.beginPath();
            ctx.arc(0, 0, r, startAngle, endAngle);
            ctx.strokeStyle = `rgba(${localColor.r},${localColor.g},${localColor.b},${alpha})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    // Update info
    function updateInfo() {
        const rs = getRS(state.mass);
        document.getElementById('infoMass').textContent = state.mass + ' M☉';
        document.getElementById('infoRs').textContent = (rs * state.mass).toFixed(1) + ' km';
        document.getElementById('infoPhoton').textContent = (rs * 1.5 * state.mass).toFixed(1) + ' km';
        document.getElementById('massVal').textContent = state.mass + ' M☉';
        document.getElementById('tempVal').textContent = state.temp + ' K';
    }
    
    // Controls
    document.getElementById('mass').addEventListener('input', e => {
        state.mass = parseInt(e.target.value);
        updateInfo();
    });
    
    document.getElementById('temp').addEventListener('input', e => {
        state.temp = parseInt(e.target.value);
        updateInfo();
    });
    
    document.getElementById('showDisk').addEventListener('change', e => {
        state.showDisk = e.target.checked;
    });
    
    document.getElementById('showStars').addEventListener('change', e => {
        state.showStars = e.target.checked;
    });
    
    // Touch events
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        lastTouches = Array.from(e.touches);
        
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastDistance = Math.sqrt(dx * dx + dy * dy);
        }
        
        document.getElementById('hint').classList.add('hidden');
    }, { passive: false });
    
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        
        if (e.touches.length === 1 && lastTouches.length === 1) {
            // Rotation
            const dx = e.touches[0].clientX - lastTouches[0].clientX;
            state.rotation += dx * 0.01;
        } else if (e.touches.length === 2) {
            // Zoom
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (lastDistance > 0) {
                const scale = distance / lastDistance;
                state.zoom = Math.max(0.3, Math.min(3, state.zoom * scale));
            }
            
            lastDistance = distance;
        }
        
        lastTouches = Array.from(e.touches);
    }, { passive: false });
    
    canvas.addEventListener('touchend', e => {
        lastTouches = Array.from(e.touches);
        if (e.touches.length < 2) lastDistance = 0;
    });
    
    // Mouse fallback
    let isDragging = false;
    let lastMouseX = 0;
    
    canvas.addEventListener('mousedown', e => {
        isDragging = true;
        lastMouseX = e.clientX;
        document.getElementById('hint').classList.add('hidden');
    });
    
    canvas.addEventListener('mousemove', e => {
        if (isDragging) {
            state.rotation += (e.clientX - lastMouseX) * 0.01;
            lastMouseX = e.clientX;
        }
    });
    
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);
    
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        state.zoom = Math.max(0.3, Math.min(3, state.zoom * (e.deltaY > 0 ? 0.95 : 1.05)));
    }, { passive: false });
    
    // Animation loop
    function animate() {
        state.time += 0.016;
        draw();
        requestAnimationFrame(animate);
    }
    
    // Init
    window.addEventListener('resize', resize);
    resize();
    updateInfo();
    animate();
    
    // Hide hint after 3 seconds
    hintTimeout = setTimeout(() => {
        document.getElementById('hint').classList.add('hidden');
    }, 3000);
</script>
```

</body>
</html>